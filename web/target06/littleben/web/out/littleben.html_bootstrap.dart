import "dart:async" as kB;import "dart:collection" as lB;import "dart:html" as DB;import "dart:isolate" as FD;class rC{static const  sC="Chrome";final  kC;final  minimumVersion;const rC(this.kC,[this.minimumVersion]);}class tC{const tC();}class uC{final  name;const uC(this.name);}class vC{const vC();}class wC{const wC();}final UB=new m();var VB; get AC{if(MC){NC(UB,AB.YB,'currentTime');}return VB;}set AC( g){if(LC(UB)){OC(UB,AB.YB,'currentTime',VB,g);}VB=g;} BC(){var g=new Duration(seconds:1);new kB.Timer.periodic(g,mB);mB(null);} mB( KD){var g=new DateTime.now();AC=CC(g.hour,g.minute,g.second);} CC( g, h, i){if(g>12){g=g-12;}var j=(h<=9)?'0${h}':'${h}';var k=(i<=9)?'0${i}':'${i}';return '${g}:${j}:${k}';} DC(){var LD=DB.document.body;var MD;var ND=new zC(LD);MD=LD.nodes[3];var OD=ND.lC(()=>AC,false);MD.nodes.addAll([new DB.Text('\n      The current time is: '),OD,new DB.Text('\n    ')]);ND.hB();ND.insert();}main(){rB=true;v.XB.pC.listen((g){print('${g.NB.name.toLowerCase()}: ${g.message}');});BC();DC();}var WB=false;var EC=l.nB;class v{final  name; get vB=>(parent==null||parent.name=='')?name:'${parent.vB}.${name}';final  parent;var PD;var children;var QD;var RD;factory v( g){if(g.startsWith('.')){throw new ArgumentError("name shouldn't start with a '.'");}if(HB==null)HB=<String,v>{};if(HB.containsKey(g))return HB[g];var j=g.lastIndexOf('.');var h=null;var i;if(j==-1){if(g!='')h=new v('');i=g;}else{h=new v(g.substring(0,j));i=g.substring(j+1);}final k=new v.GD(i,h);HB[g]=k;return k;}v.GD(this.name,this.parent):children=new Map<String,v>(){if(parent!=null)parent.children[name]=this;} get NB{if(WB){if(PD!=null)return PD;if(parent!=null)return parent.NB;}return EC;} get pC=>SD(); mC( g)=>(g>=NB); log( i, k,[j]){if(mC(i)){var h=new IB(i,k,vB,j);if(WB){var g=this;while (g!=null){g.TD(h);g=g.parent;}}else{XB.TD(h);}}} info( h,[g])=>log(l.nB,h,g); yB( h,[g])=>log(l.FC,h,g); SD(){if(WB||parent==null){if(QD==null){QD=new kB.StreamController<IB>.broadcast(sync:true);RD=QD.stream;}return RD;}else{return XB.SD();}} TD( g){if(QD!=null){QD.add(g);}}static  get XB=>new v('');static var HB;}class l implements Comparable<l>{final  name;final  value;const l(this.name,this.value);static const  nB=const l('INFO',800);static const  FC=const l('WARNING',900); operator==( g)=>g!=null&&value==g.value; operator<( g)=>value<g.value; operator<=( g)=>value<=g.value; operator>( g)=>value>g.value; operator>=( g)=>value>=g.value; compareTo( g)=>value-g.value; get hashCode=>value; toString()=>name;}class IB{final  NB;final  message;final  nC;final  time;final  qC;static var GC=0;var exception;IB(this.NB,this.message,this.nC,[this.exception]):time=new DateTime.now(),qC=IB.GC++ ;}typedef  t( e);typedef  HC( changes);typedef  w();typedef  IC();class PB{final oldValue;final newValue;final  changes;PB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is PB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>YC(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class AB{static const YB=1;static const ZB=2;static const oB=ZB|4;static const pB=ZB|8;final  type;final key;final oldValue;final newValue;AB(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is AB&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>ZC(type,key,oldValue,newValue); toString(){var g;switch (type){case YB:g='field';break;case ZB:g='index';break;case oB:g='insert';break;case pB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} JC(g, i,[ k]){if(g is m){var h=g;return aB(h,(o){i(new PB(h,h,o));});}var j=new QB(g,i,k);if(!j.UD()){return PC;}return j.VD;} aB( g, i){if(g.GB==null)g.GB=new bB();var h=g.GB.add(i);return h.remove;}class m{var GB;var FB;final  hashCode= ++m.KC;static var KC=0;} LC( g)=>g.GB!=null&&g.GB.head!=null; get MC=>EB!=null; NC( g, h,i)=>EB.WD(g,h,i); OC( g, j,k, h, i){if((j&(AB.oB|AB.pB))==0){if(h==i)return;}if(BB==null){BB=[] ;aC(QC);}if(g.FB==null){g.FB=[] ;BB.add(g);}g.FB.add(new AB(j,k,h,i));} PC(){}var EB;var qB=100;var BB;var CB; QC(){var o=0;while (BB!=null||CB!=null){var j=BB;BB=null;var i=CB;CB=null;if(o++ ==qB){RC(j,i);return;}if(j!=null){for(var h in j){var OB=h.FB;h.FB=null;for(var g=h.GB.head;g!=null;g=g.next){var k=g.value;try {k(OB);}catch (jB,u){JB(jB,u,k,'from ${h}');}}}}if(i!=null){i.forEach((zB,iB){iB.XD();});}}} RC( k, j){var g=[] ;if(k!=null){for(var i in k){var OB=i.FB;g.add('${i} ${OB}');}}if(j!=null){for(var o in j.values){var h=o.XD();if(h!=null)g.add('${o} ${h}');}}BB=null;CB=null;var u='exceeded notifiction limit of ${qB}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';UC(u);}class QB{static var SC=0;final  YD= ++QB.SC;final  ZD;final  aD;final  bD;final  cD=new Map();final  dD=[] ;var eD=false;var fD;QB(this.ZD,this.aD,this.bD); toString()=>bD!=null?'<observer ${YD}: ${bD}>':'<observer ${YD}>'; UD(){var h=EB;EB=this;try {fD=ZD();if(fD is Iterable&&fD is !List&&fD is !m){fD=(fD as Iterable).toList();}}catch (g,i){JB(g,i,ZD,'from ${this}');fD=null;}cD.forEach(gD);cD.clear();assert(EB==this);EB=h;hD();return dD.length>0;} iD( i){try {aD(i);}catch (g,h){JB(g,h,aD,'from ${this}');}} hD(){var g=fD;if(g is !m)return;dD.add(aB(g,(h){iD(new PB(g,g,h));}));} WD( o, u,g){var i=cD.putIfAbsent(o,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|u;}catch (j,k){JB(j,k,g,'hashCode or operator == from ${this}');}} gD( i, j){dD.add(aB(i,(k){if(eD)return;for(var g in k){var h=j[g.key];if(h!=null&&(h&g.type)!=0){eD=true;if(CB==null){CB=new lB.SplayTreeMap();}CB[YD]=this;return;}}}));} VD(){for(var g in dD){g();}eD=false;} XD(){if(!eD)return null;var g=fD;VD();UD();try {if(g==fD)return null;}catch (i,j){JB(i,j,g,'operator == from ${this}');return null;}var h=new PB(g,fD);iD(h);return h;}}typedef  TC( message);var UC=(g)=>print(g);typedef  VC(error,stackTrace,obj, message);var JB=WC; WC(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class XC{}class q<s>{var jD;var kD;var lD;var mD;q.HD( g,this.lD):mD=g{if(lD!=null)lD.nD++ ;} get next=>kD; get value=>mD;set value( g)=>mD=g; oD( g, h){kD=h;jD=g;if(g!=null)g.kD=this;if(h!=null)h.jD=this;return this;} append( g)=>new q<s>.HD(g,lD).oD(this,kD); remove(){if(lD==null)return;lD.nD-- ;if(jD!=null){jD.kD=kD;}else{lD.pD=kD;}if(kD!=null){kD.jD=jD;}else{lD.qD=jD;}kD=null;jD=null;lD=null;}}class bB<s> extends lB.IterableBase<s>{var pD;var qD; get length=>nD;var nD=0;bB(){} get head=>pD; add( h){var g=new q<s>.HD(h,this);if(qD==null)return pD=qD=g;return qD=g.oD(qD,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new xC<s>(this);}class xC<s> implements Iterator<s>{var rD;var lD;var sD;var tD=-1;xC(this.lD){rD=new List<q>(lD.length);var h=0;var g=lD.head;while (g!=null){rD[h++ ]=g;g=g.next;}} get current=>sD; moveNext(){do{tD++ ;}while(tD<rD.length&&rD[tD].lD!=lD);if(tD<rD.length){sD=rD[tD].value;return true;}else{sD=null;return false;}}}KB(h,g)=>h.hashCode*31+g.hashCode;YC(h,g,i)=>KB(KB(h,g),i);ZC(g,i,h,j)=>KB(KB(g,i),KB(h,j)); aC( h()){var g=new FD.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);} bC(i, g,[ h]){var j=i is XC;if(h==null){h=i.toString();}if(!j&&g is DB.Text){g.text=h;}else{var k=g;g=j?new DB.Element.html(h):new DB.Text(h);k.replaceWith(g);}return g;}abstract class cB{ hB(){} insert(); remove();}abstract class cC extends cB{final exp;final  isFinal;final  tB;var TB;cC(this.exp,this.isFinal):tB=dB&&RB!=null?RB():null; insert(){if(isFinal){wB();}else if(TB!=null){throw new StateError('binding already attached');}else{TB=xB();}} remove(){if(!isFinal){TB();TB=null;}} wB(); xB();}class yC extends cC{final  action;yC(g,this.action, h):super(g,h); wB()=>action(new PB(null,exp())); xB()=>fC(exp,action,'generic-binding',tB);}class zC extends cB{final  oC;final  children=[] ;final  nodes=[] ;zC(this.oC); lC( h,i){var g=new DB.Text('');children.add(new yC(()=>'${h()}',(j){g=bC(h(),g,j.newValue);},i));return g;} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); hB(){for(var g=0,h=children.length;g<h;g++ ){children[g].hB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var rB=false;var dB=false;var RB=(){try {throw "";}catch (h,g){return g.toString();}};final  SB=new v('watcher'); dC(g, u,[ j, o]){if(rB)return JC(g,u);if(u==null)return (){};if(eB==null)eB=new bB<LB>();j=j==null?'<unnamed>':j;var i;var h=n.jC;if(g is sB){i=(g as sB).uD;}else if(g is Function){i=g;try {var k=g();if(k is List){h=n.MB;}else if(k is Iterable){h=n.MB;i=()=>g().toList();}else if((k is lB.LinkedHashMap)||(k is lB.SplayTreeMap)){h=n.gB;}else if(k is Map){h=n.fB;}}catch (OB,iB){SB.yB('evaluating ${j} watcher threw error (${OB}, ${iB})');}}else if(g is List){i=()=>g;h=n.MB;}else if(g is Iterable){i=()=>g.toList();h=n.MB;}else if((g is lB.LinkedHashMap)||(g is lB.SplayTreeMap)){i=()=>g;h=n.gB;}else if(g is Map){i=()=>g;h=n.fB;}if(dB&&o==null&&RB!=null){o=RB();}var zB=eC(h,i,u,j,o);var jB=eB.add(zB);return jB.remove;} eC( k, g, j, h, i){switch (k){case n.MB:return new AD(g,j,h,i);case n.gB:return new ED(g,j,h,i);case n.fB:return new BD(g,j,h,i);default:return new LB(g,j,h,i);}} fC(h, i,[ j, k]){var o=dC(h,i,j,k);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new PB(null,g));return o;}var eB;class LB{final  uB;var location;final  vD;static var gC=0;final  uD;final  wD;var xD;LB(this.uD,this.wD,this.uB,this.location):vD=gC++ {xD=uD();} toString()=>'${uB} (id: #${vD})'; yD(g){if(dB){if(location!=null){SB.info('watcher updated: ${this}, defined at:\n${location}');location=null;}else{SB.info('watcher updated: ${this}');}}xD=g;}zD(){try {return uD();}catch (g,h){SB.yB('${this} watcher threw an exception: ${g}, ${h}');}return xD;}}typedef  hC<iC>();class sB<iC>{}class AD<iC> extends LB{AD(g, j, h, i):super(g,j,h,i){yD(zD());} yD(g){xD=new List<iC>.from(g);}}class BD<CD,DD> extends LB{BD(g, j, h, i):super(g,j,h,i){yD(zD());} yD(g){xD=new Map<CD,DD>.from(g);}}class ED<CD,DD> extends LB{ED(g, j, h, i):super(g,j,h,i){yD(zD());} yD(g){xD=new lB.LinkedHashMap.from(g);}}class n{final AE;const n.ID(this.AE);toString()=>'Enum.${AE}';static const MB=const n.ID('LIST');static const fB=const n.ID('HASH_MAP');static const gB=const n.ID('ORDERED_MAP');static const jC=const n.ID('OTHER');}//@ sourceMappingURL=littleben.html_bootstrap.dart.map
