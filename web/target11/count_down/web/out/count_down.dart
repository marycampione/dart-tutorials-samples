// Auto-generated from count_down.html.
// DO NOT EDIT.

library count_down_html;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import 'xcountdown.dart';
import 'dart:async';
import 'dart:indexed_db';
import 'milestone.dart';


// Original code


/*
 * The VIEW-MODEL for the app.
 * 
 * Implements the business logic 
 * and manages the information exchanges
 * between the MODEL (Milestone & MilestoneStore)
 * and the VIEW (CountDownComponent & MilestoneComponent).
 * 
 * Manages a Timer to update the milestones.
 */

MilestoneApp appObject = new MilestoneApp();

void main() {
}

class MilestoneApp {
  /****
   * Some things we need...
   */
  // When there are no active milestones, timer is null.
  Timer timer = null;
  
  // Is IndexedDB supported in this browser?
  bool idbAvailable = IdbFactory.supported;
  
  // A place to save the milestones (is the MODEL).
  MilestoneStore _store = new MilestoneStore();
  
  // Called from the VIEW.
  bool get hazMilestones => (milestones.length == 0) ? false : true;
  
  // The list of milestones in the MODEL.
  List<Milestone> get milestones => _store.milestones;
 
  /****
   * Life-cycle methods...
   */
  
  // Called from the VIEW when the element is inserted into the DOM.
  Future start() {
      if (!idbAvailable) {
        return new Future.error('IndexedDB not supported.');
      }
      
      return _store.open().then((_) {
        _startMilestoneTimer();
      });
  }
  
  // Called from the VIEW when the element is removed from the DOM.
  void stop() {
    _stopMilestoneTimer(true);
  }

  /****
   * Click handlers...
   * Called from the VIEW (xcountdown) when the user clicks a button.
   * Delegates to MODEL.
   */
  
  void addMilestone(String milestoneName, DateTime occursOn) {
    // Make sure milestone is in the future, and not in the past.
    if (occursOn.isAfter(new DateTime.now())) {
      _store.add(milestoneName, occursOn).then((_) {
        _startMilestoneTimer();
      },
      onError: (e) { print('duplicate key'); } );
    }
  }

  Future removeMilestone(Milestone milestone) {
    return _store.remove(milestone).then((_) {
      _stopMilestoneTimer(false);
    });
  }
  
  Future clear() {
    return _store.clear().then((_) {
      _stopMilestoneTimer(false);
    });
  }
   
  /****
   * Timer stuff.
   */
  // Starts the timer if it's off and there are milestones.
  void _startMilestoneTimer() {
    if (timer == null && milestones.length > 0) {
      // The timer goes off every second.
      var oneSecond = new Duration(seconds:1);
      timer = new Timer.periodic(oneSecond, _tick);
    }
  }
  
  // Turn off the timer if no milestones or they are all elapsed.
  void _stopMilestoneTimer(bool quitting) {
    if (quitting || (timer != null && milestones.where((m) => !m.elapsed).isEmpty)) {
      timer.cancel();
      timer = null;
    }
  }
  
  // Update the display for each milestone.
  void _tick(Timer _) {
    // For each milestone, update the time remaining...
    for (int i = 0; i < milestones.length; i++) {
      milestones[i].tick();
    }
  }
}
// Additional generated code
void init_autogenerated() {
  var __root = autogenerated.document.body;
  var __e0;
  var __t = new autogenerated.Template(__root);
  __e0 = __root.nodes[5];
  __t.component(new CountDownComponent()..host = __e0);
  __t.create();
  __t.insert();
}

//# sourceMappingURL=count_down.dart.map